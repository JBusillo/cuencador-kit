/**
 * @param {import('@sveltejs/kit').Request} request
 * @param {any} context
 * @returns {import('@sveltejs/kit').Response}
 */
import { facebookConfig } from '$lib/config/login.config'
import fetch from 'node-fetch'
import { getSession } from '$lib/config/database.config'
import crypto from 'crypto'

export async function get(request, context) {

    //    let loginConfig = await getLoginConfig()
    let user_access_token = request.query.get('token')

    //verify the access token
    let url = `https://graph.facebook.com/debug_token?input_token=${user_access_token}&access_token=${facebookConfig.FacebookAppAccessToken}`
    let response = await fetch(url, {
        method: 'GET'
    })
    let data = await response.json()
    let user_id = data.data.user_id

    // exchange for a long lived token
    url = 'https://graph.facebook.com/v10.0/oauth/access_token?grant_type=fb_exchange_token' +
        `&client_id=${facebookConfig.FacebookClientId}` +
        `&client_secret=${facebookConfig.FacebookSecret}` +
        `&fb_exchange_token=${user_access_token}` +
        `&redirect_uri=${facebookConfig.FacebookRedirectUri}`;

    response = await fetch(url, {
        method: 'GET'
    })
    data = await response.json()
    user_access_token = data.access_token

    // get requested data
    url = `https://graph.facebook.com/${user_id}?fields=id,name,email&access_token=${user_access_token}`
    response = await fetch(url, {
        method: 'GET'
    })
    data = await response.json()

    let sess = await getSession()
    let x = await sess.getSchema('Cuencador')
        .getTable('Users')
        .insert(['social_key', 'name', 'email', 'uat'])
        .values(`F${data.id}`, data.name, data.email, user_access_token)
        .execute();

    let userId = (x.getAutoIncrementValue()).toString()
    console.log(`Autogenerated Id: ${userId}`);

    sess.close()




    return {
        body: {
            ok: true,
            userdata: data,
            userId: userId
        }
    }

    function encrypt(plainText) {
        // encrypt code /////////////////////////////////////////////////////
        const algorithm = 'aes-192-cbc';
        const password = 'This is the password';
        const key = crypto.scryptSync(password, 'salt', 24);
        const iv = Buffer.alloc(16, 0); // Initialization vector.
        const cipher = crypto.createCipheriv(algorithm, key, iv);

        let encrypted = cipher.update(`{ "unencrypted" : "${plainText}"`, 'utf8', 'hex');
        encrypted += cipher.final('hex');
        console.log(`encrypted: ${encrypted}`);
        return encrypted
        // encrypt code /////////////////////////////////////////////////////
    }

    async function test() {
        try {
            const claims = await admin.auth().verifyIdToken(data.idToken);
            if (new Date().getTime() / 1000 - claims.auth_time < 5 * 60) {
                const expiresIn = 60 * 60 * 24 * 7 * 1000;
                const sessionCookie = await admin.auth().createSessionCookie(data.idToken, { expiresIn });
                return {
                    headers: {
                        'Set-Cookie': `_session=${sessionCookie}; Path=/; Max-Age=${expiresIn}; HttpOnly; Secure`
                    },
                    body: {
                        ok: true,
                        user: claims && {
                            uid: claims.uid,
                            name: claims.name,
                            email: claims.email,
                            email_verified: claims.email_verified,
                            role: claims.role
                        }
                    }
                };
            }
        } finally { }
    }
}